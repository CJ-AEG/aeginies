import streamlit as st
import pandas as pd
import numpy as np
import requests
import json
import time
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.edge.options import Options
from tqdm import tqdm
import plotly.express as px

# ‚úÖ Titre de l'application
st.set_page_config(layout="wide")
st.title("Analyse des Z-Scores - Aeginies")

# ‚úÖ D√©claration globale du dataframe
global df
df = pd.DataFrame()

# ‚úÖ Fonction pour charger automatiquement depuis GitHub
@st.cache_data
def load_data_from_repo():
    url = 'https://raw.githubusercontent.com/CJ-AEG/aeginies/main/base_inies_complete.xlsx'
    df = pd.read_excel(url, sheet_name="Sheet1")
    return df

# ‚úÖ Fonction de cache pour le fichier upload√©
@st.cache_data
def load_data(file):
    df = pd.read_excel(file, sheet_name="Sheet1")
    return df

# ‚úÖ Zone pour uploader un fichier Excel (optionnel)
uploaded_file = st.file_uploader("üìÇ Importer un fichier Excel", type=["xlsx"])

# ‚úÖ Chargement des donn√©es depuis GitHub si aucun fichier n'est upload√©
if uploaded_file is not None:
    df = load_data(uploaded_file)
    st.success("‚úÖ Fichier charg√© depuis le t√©l√©chargement !")
else:
    df = load_data_from_repo()
    st.success("‚úÖ Base de donn√©es charg√©e automatiquement depuis le d√©p√¥t GitHub !")

# ‚úÖ Affichage des donn√©es import√©es AVANT traitement
if not df.empty:
    st.write("### üîé Donn√©es import√©es :")
    st.dataframe(df)

# ‚úÖ Fonction pour r√©cup√©rer les derniers IDs depuis l'API INIES
def fetch_latest_inies_data():
    url = "https://base-inies.fr/api/SearchProduits"
    payload = {
        "typeDeclaration": 0,
        "cov": 0,
        "onlineDate": 0,
        "lieuProduction": 0,
        "perfUF": 0,
        "norme": 0,
        "onlyArchive": False
    }
    headers = {
        "Content-Type": "application/json",
        "Accept": "application/json"
    }

    response = requests.post(url, json=payload, headers=headers)

    if response.status_code == 200:
        try:
            data = response.json()
            if isinstance(data, list):
                st.success(f"‚úÖ {len(data)} IDs INIES r√©cup√©r√©s avec succ√®s !")
                return [str(item) for item in data]
            else:
                st.warning("‚ö†Ô∏è Format de donn√©es inattendu.")
                return []
        except json.JSONDecodeError:
            st.error("‚ö†Ô∏è Erreur de d√©codage JSON.")
            return []
    else:
        st.error(f"‚ùå Erreur d'acc√®s √† l'API INIES : {response.status_code} {response.reason}")
        return []

# ‚úÖ Fonction de mise √† jour des donn√©es
def update_inies_data():
    global df
    latest_ids = fetch_latest_inies_data()
    if not latest_ids:
        return
    
    if df.empty:
        existing_ids = set()
    else:
        existing_ids = set(df['ID INIES'].astype(str))

    new_entries = set(map(str, latest_ids)) - existing_ids

    if new_entries:
        st.info(f"üîÑ Mise √† jour en cours avec {len(new_entries)} nouveaux produits...")

        options = Options()
        options.add_argument("--headless")
        driver = webdriver.Edge(options=options)

        product_data = []
        for id_inies in tqdm(new_entries, desc="Extraction"):
            try:
                driver.get(f"https://base-inies.fr/consultation/infos-produit/{id_inies}")
                WebDriverWait(driver, 15).until(
                    EC.presence_of_element_located((By.XPATH, '//*[@id="workSpace"]'))
                )
                time.sleep(2)

                # ‚úÖ Produit
                try:
                    product_name = driver.find_element(By.XPATH, '//*[@id="workSpace"]/div/infos-produit/div/div[3]/informations-generales-read-only/div/div[1]/div[2]/span[1]').text.strip()
                except:
                    product_name = "Nom introuvable"

                # ‚úÖ Dur√©e de vie
                try:
                    duree_vie = driver.find_element(By.XPATH, '//*[@id="workSpace"]/div/infos-produit/div/div[3]/unite-fonctionnelle-read-only/div/div[3]/div[2]/span').text.strip().replace('ans', '').strip()
                    duree_vie = float(duree_vie) if duree_vie != '' else np.nan
                except:
                    duree_vie = np.nan

                # ‚úÖ Impact CO2 + D-b√©n√©fices
                try:
                    impact_co2 = float(driver.find_element(By.XPATH, '...').text)
                    d_benefices = float(driver.find_element(By.XPATH, '...').text)
                except:
                    impact_co2 = 0
                    d_benefices = 0

                product_data.append([id_inies, product_name, duree_vie, impact_co2, d_benefices])

            except Exception as e:
                st.warning(f"‚ö†Ô∏è Erreur lors de l'extraction de l'ID {id_inies} : {e}")

        driver.quit()

        new_df = pd.DataFrame(product_data, columns=['ID INIES', 'Nom du produit', 'Dur√©e de Vie', 'Impact CO‚ÇÇ (kg)', 'D-B√©n√©fices'])
        df = pd.concat([df, new_df], ignore_index=True).drop_duplicates(subset=['ID INIES'], keep='last')
        st.success("‚úÖ Base de donn√©es mise √† jour avec succ√®s !")

# ‚úÖ Fonction de traitement apr√®s recherche
def process_data(filtered_data):
    if filtered_data.empty:
        st.warning("‚ö†Ô∏è Aucun √©l√©ment trouv√©.")
        return

    # ‚úÖ Conversion explicite en float (gestion d'erreur)
    filtered_data['Impact CO‚ÇÇ (kg)'] = pd.to_numeric(filtered_data['Impact CO‚ÇÇ (kg)'], errors='coerce').fillna(0)
    filtered_data['D-B√©n√©fices'] = pd.to_numeric(filtered_data['D-B√©n√©fices'], errors='coerce').fillna(0)

    filtered_data['Impact total'] = filtered_data['Impact CO‚ÇÇ (kg)'] + filtered_data['D-B√©n√©fices']

    # ‚úÖ Z-Score
    mean = filtered_data['Impact total'].mean()
    std = filtered_data['Impact total'].std()
    filtered_data['Z-Score'] = (filtered_data['Impact total'] - mean) / std

    # ‚úÖ Cat√©gorisation
    filtered_data['Cat√©gorie'] = pd.cut(
        filtered_data['Z-Score'],
        bins=[-np.inf, -1, 1, np.inf],
        labels=['Bas carbone', 'Interm√©diaire', 'Haut carbone']
    ).astype(str)

    # ‚úÖ Affichage tableau
    st.write("### ‚úÖ R√©sultats apr√®s traitement des donn√©es :")
    st.dataframe(filtered_data)

# ‚úÖ Bouton de mise √† jour
if st.sidebar.button("üîÑ Mettre √† jour"):
    update_inies_data()

# ‚úÖ Champ de recherche
search_term = st.text_input("üîé Type d'√©l√©ment √† afficher (exemple : Plancher bois)")

if search_term:
    terms = search_term.split()
    filtered_data = df[
        np.logical_and.reduce([df['Nom du produit'].str.contains(term, case=False, na=False) for term in terms])
    ]
    if not filtered_data.empty:
        st.dataframe(filtered_data)
        if st.button("üîé Traiter les donn√©es"):
            process_data(filtered_data)

